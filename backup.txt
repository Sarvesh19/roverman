"use client";

import { useEffect, useState, useRef } from "react";
import { useSearchParams, useRouter } from "next/navigation";
import Navbar from "../component/navbar";
import Footer from "../component/footer";
import { Card } from "@/components/ui/card";
import { Skeleton } from "@/components/ui/skeleton";
import { Button } from "@/components/ui/button";
import { Calendar, MapPin, Plus, Check, Plane, DollarSign, Heart, Image as ImageIcon, Search } from "lucide-react";
import { ArrowRight } from "lucide-react";
import { Slider } from "@/components/ui/slider";
import { supabase } from '../../lib/supabaseClient';
import { insertTripSuggestions, updateDestinationWeightage } from '../services/trip-service-dao';
import { TripSuggestion } from "../model/tripSuggestion";
import { ToastContainer, toast } from 'react-toastify';
import 'react-toastify/dist/ReactToastify.css';
import { Input } from "@/components/ui/input";

const Results = () => {
  interface Trip {
    id: string;
    destination: string;
    cost: string;
    activities: string;
    image: string;
    description: string;
  }

  const [tripSuggestions, setTripSuggestions] = useState<TripSuggestion[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const searchParams = useSearchParams();
  const router = useRouter();
  const [imagesFetched, setImagesFetched] = useState(false);
  const [selectedTrips, setSelectedTrips] = useState<string[]>([]);
  const [favoritedTrips, setFavoritedTrips] = useState<string[]>([]);
  const [hoveredCard, setHoveredCard] = useState<string | null>(null);
  const [isMobile, setIsMobile] = useState(false);
  const [fetchedDestinations, setFetchedDestinations] = useState<string[]>([]);
  const [isInitialLoad, setIsInitialLoad] = useState(true);
  const tripSuggestionsRef = useRef<TripSuggestion[]>([]);
  const [radius, setRadius] = useState([100]);
  const [galleryImages, setGalleryImages] = useState<string[]>([]);
  const [isGalleryOpen, setIsGalleryOpen] = useState(false);
  const [currentDestination, setCurrentDestination] = useState<string>('');
  const [isSearchOverlayOpen, setIsSearchOverlayOpen] = useState(false);
  const [selectedImageIndex, setSelectedImageIndex] = useState<number | null>(null);
  // Swipe gesture states
  const [touchStart, setTouchStart] = useState<number | null>(null);
  const [touchEnd, setTouchEnd] = useState<number | null>(null);
  // Search form states
  const [fromInput, setFromInput] = useState(searchParams.get("from") || "");
  const [destinationInput, setDestinationInput] = useState(searchParams.get("destination") || "");
  const [daysInput, setDaysInput] = useState(searchParams.get("duration") || "");

  const API_URL_GROQ = "https://api.groq.com/openai/v1/chat/completions";
  const API_KEY_GROQ = process.env.NEXT_PUBLIC_API_KEY_GROQ;
  const GROQ_MODEL = process.env.NEXT_PUBLIC_GROQ_MODEL;
  const WIKI_MEDIA_API_URL = "https://commons.wikimedia.org/w/api.php?action=query&format=json&generator=search&gsrsearch=";
  const GEMINI_URL = process.env.NEXT_PUBLIC_API_URL_GEMINI;
  const GEMINI_API_KEY = process.env.NEXT_PUBLIC_API_KEY_GEMINI;
  const GEMINI_API_KEY_Backup1 = process.env.NEXT_PUBLIC_API_KEY_GEMINI_BACKUP1;

  const budget = searchParams.get("budget");
  const duration = searchParams.get("duration");
  const from = searchParams.get("from");

  // Minimum swipe distance (in pixels) to trigger navigation
  const minSwipeDistance = 50;

  const handleTouchStart = (e: React.TouchEvent<HTMLDivElement>) => {
    setTouchStart(e.targetTouches[0].clientX);
    setTouchEnd(null);
  };

  const handleTouchMove = (e: React.TouchEvent<HTMLDivElement>) => {
    setTouchEnd(e.targetTouches[0].clientX);
  };

  const handleTouchEnd = () => {
    if (touchStart === null || touchEnd === null) return;

    const distance = touchStart - touchEnd;
    const isLeftSwipe = distance > minSwipeDistance;
    const isRightSwipe = distance < -minSwipeDistance;

    if (isLeftSwipe && selectedImageIndex !== null && selectedImageIndex < galleryImages.length - 1) {
      setSelectedImageIndex(prev => (prev !== null ? prev + 1 : prev));
    }
    if (isRightSwipe && selectedImageIndex !== null && selectedImageIndex > 0) {
      setSelectedImageIndex(prev => (prev !== null ? prev - 1 : prev));
    }

    setTouchStart(null);
    setTouchEnd(null);
  };

  const handleTripSelection = (tripId: string, e?: React.MouseEvent) => {
    e?.stopPropagation();
    setSelectedTrips(prev =>
      prev.includes(tripId)
        ? prev.filter(id => id !== tripId)
        : [...prev, tripId]
    );
  };

  const handleFavoriteTrip = async (destination: string, highlights: string, image: string, e?: React.MouseEvent) => {
    e?.stopPropagation();
    const isFavorited = favoritedTrips.includes(destination);
    const userId = localStorage.getItem("user_id");

    if (!userId) {
      toast.error("Please login first to favorite a trip!");
      return;
    }
    setFavoritedTrips(prev =>
      isFavorited
        ? prev.filter(id => id !== destination)
        : [...prev, destination]
    );

    if (!isFavorited) {
      const { error } = await supabase
        .from('tripigo_user_trip_favourite')
        .insert({
          user_id: userId,
          destination: destination,
          highlights: highlights,
          image: image,
          created_at: new Date().toISOString(),
        });

      if (error) {
        console.error("Error saving favorite trip:", error);
        setFavoritedTrips(prev => prev.filter(id => id !== destination));
      }
    } else {
      const { error } = await supabase
        .from('tripigo_user_trip_favourite')
        .delete()
        .match({ user_id: userId, destination: destination });

      if (error) {
        console.error("Error removing favorite trip:", error);
        setFavoritedTrips(prev => [...prev, destination]);
      }
    }
  };

  const handleViewDetails = (destination: string, e?: React.MouseEvent) => {
    e?.stopPropagation();
    const queryParams = new URLSearchParams({
      budget: budget || "",
      duration: duration || "",
      from: from || "",
      destination: searchParams.get("destination") || "",
    }).toString();
    router.push(`/trips/${destination.toLowerCase().replace(/\s+/g, '-')}?${queryParams}`);
  };

  const openImageGallery = async (destination: string, e?: React.MouseEvent) => {
    e?.stopPropagation();
    setCurrentDestination(destination);
    const images = await getFlickrImages(destination, '76e4ffdde05ab7132abfbbb8dea0e2da');
    setGalleryImages(images);
    setIsGalleryOpen(true);
  };

  const closeGallery = () => {
    setIsGalleryOpen(false);
    setGalleryImages([]);
    setCurrentDestination('');
  };

  const toggleSearchOverlay = () => {
    setIsSearchOverlayOpen(!isSearchOverlayOpen);
  };

  const handleSearchSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    const newParams = new URLSearchParams({
      from: fromInput,
      destination: destinationInput,
      duration: daysInput,
      budget: budget || "",
    });
    router.push(`/results?${newParams.toString()}`);
    setFetchedDestinations([]);
    fetchTripSuggestions();
    setIsSearchOverlayOpen(false);
  };

  useEffect(() => {
    if (tripSuggestions.length > 0) {
      localStorage.setItem('tripSuggestions', JSON.stringify(tripSuggestions));
    }
  }, [tripSuggestions]);

  useEffect(() => {
    if (selectedTrips.length > 0) {
      localStorage.setItem('selectedTrips', JSON.stringify(selectedTrips));
    }
  }, [selectedTrips]);

  const handleNext20 = () => {
    fetchTripSuggestions();
  };

  useEffect(() => {
    const checkIfMobile = () => {
      setIsMobile(window.innerWidth <= 768);
    };

    checkIfMobile();
    window.addEventListener('resize', checkIfMobile);

    return () => {
      window.removeEventListener('resize', checkIfMobile);
    };
  }, []);

  useEffect(() => {
    const userId = localStorage.getItem("user_id");
    const storedTripSuggestions = localStorage.getItem('tripSuggestions');
    const storedSelectedTrips = localStorage.getItem('selectedTrips');

    if (storedTripSuggestions) {
      setTripSuggestions(JSON.parse(storedTripSuggestions));
    } else {
      fetchTripSuggestions();
    }

    if (storedSelectedTrips) {
      setSelectedTrips(JSON.parse(storedSelectedTrips));
    }

    const fetchFavoritedTrips = async () => {
      const { data, error } = await supabase
        .from('tripigo_user_trip_favourite')
        .select('destination')
        .eq('user_id', userId);

      if (error) {
        console.error("Error fetching favorited trips:", error);
      } else if (data) {
        setFavoritedTrips(data.map(item => item.destination));
      }
    };
    fetchFavoritedTrips();
  }, []);

  const fetchTripSuggestions = async () => {
    const uniqueFetchedDestinations = [...new Set(fetchedDestinations)];
    const excludeDestinations = `**DO NOT** include these places: ${uniqueFetchedDestinations.join(", ")}`;
  
    setIsLoading(true);
    setImagesFetched(false);
  
    const attemptFetch = async (retry = false) => {
      try {
        let newTripSuggestions;
  
        // First attempt with Gemini API
        newTripSuggestions = await fetchSuggestions(GEMINI_URL, GEMINI_API_KEY, GROQ_MODEL, excludeDestinations);
  
        // If no results and not a retry, attempt again
        if (newTripSuggestions.length === 0 && !retry) {
          console.warn("No suggestions returned from Gemini API, retrying...");
          return attemptFetch(true); // Retry once
        }
  
        // If still no results after retry, throw an error
        if (newTripSuggestions.length === 0) {
          throw new Error("No trip suggestions found after retry");
        }
  
        await fetchImagesForNewSuggestions(newTripSuggestions);
        return newTripSuggestions;
      } catch (error) {
        if (!retry) {
          try {
            console.error("Error fetching from Gemini API, falling back to Gemini Backup:", error);
            const newTripSuggestions = await fetchSuggestions(GEMINI_URL, GEMINI_API_KEY_Backup1, GROQ_MODEL, excludeDestinations);
  
            if (newTripSuggestions.length === 0) {
              console.warn("No suggestions returned from Gemini Backup API, retrying...");
              return attemptFetch(true); // Retry once
            }
  
            await fetchImagesForNewSuggestions(newTripSuggestions);
            return newTripSuggestions;
          } catch (backupError) {
            console.error("Error fetching from Gemini Backup API, falling back to GROQ:", backupError);
            const newTripSuggestions_ = await fetchSuggestions_logic_groq(API_URL_GROQ, API_KEY_GROQ, GROQ_MODEL, excludeDestinations);
  
            if (newTripSuggestions_.length === 0 && !retry) {
              console.warn("No suggestions returned from GROQ API, retrying...");
              return attemptFetch(true); // Retry once
            }
  
            if (newTripSuggestions_.length === 0) {
              throw new Error("No trip suggestions found after retry");
            }
  
            await fetchImagesForNewSuggestions(newTripSuggestions_);
            return newTripSuggestions_;
          }
        } else {
          throw error; // Rethrow error after retry attempt
        }
      }
    };
  
    try {
      await attemptFetch(false); // Initial attempt
    } catch (error) {
      console.error("Final error after retries:", error);
      toast.error("use client"); // Show error message using toast
    } finally {
      setIsLoading(false);
      setIsInitialLoad(false);
    }
  };

  const fetchSuggestions_logic_groq = async (apiUrl: string, apiKey: any, model: any, excludeDestinations: string): Promise<TripSuggestion[]> => {
    setIsLoading(true);
    try {
      const response = await fetch(apiUrl, {
        method: "POST",
        headers: {
          Authorization: `Bearer ${apiKey}`,
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          stream: true,
          model: model,
          messages: [
            {
              role: "system",
              content: "You are a helpful travel assistant.",
            },
            {
              role: "user",
              content: `For ${daysInput || duration} days in ${destinationInput || searchParams.get("destination")} from ${fromInput || searchParams.get("from")} city, Places should be ${radius} km radius. Give short Highlights also dont give activities: "$30 - $50 per person" like this with price or http. Give at least 20 places suggestions where I can roam.Please please Do not include these places ${excludeDestinations} also do not include records which are not near by to ${destinationInput || searchParams.get("destination")} everytime give different places . Always give data in this format only>> 
For 4 days in Jaipur,Rajasthan, you can explore some 
of the most beautiful and exotic destinations. Here are 20 places you can 
consider:

1. **Amer fort, Jaipur, India**
   - Highlights: Amer Fort or Amber Fort is a fort located in Amer, Rajasthan, India. Amer is a town with an area of 4 square kilometres (1.5 sq mi)[2] located 11 kilometres (6.8 mi) from Jaipur, the capital of Rajasthan. Located high on a hill, it is the principal tourist attraction in Jaipur.Amer Fort is known for its artistic style elements. With its large ramparts and series of gates and cobbled paths, the fort overlooks Maota Lake, which is the main source of water for the Amer Palace.
   - Country: India
   - Cost: $10 - $20
   - Image: https://example.com/image
   - Latitude: 26.9855
   - Longitude: 75.8513
   - Tips: Visit Amer Fort early in the morning to avoid the crowds and heat.
   - Additional Activities: Visit the nearby Jaigarh Fort and Nahargarh Fort.
   - Duration: 2-3 hours
   - Best Time to Visit: October to March
   - Address: Devisinghpura, Amer, Jaipur, Rajasthan 302001
   `,
            },
          ],
        }),
      });

      const reader = response.body?.getReader();
      let responseText = "";

      if (reader) {
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          const chunk = new TextDecoder().decode(value);
          responseText += chunk;
        }
      }

      let combinedContent = '';
      const tripSuggestions = [];
      const lines = responseText.split('\n');

      for (const line of lines) {
        try {
          if (line.trim().startsWith("data: ")) {
            const jsonString = line.substring(6).trim();
            if (jsonString === "[DONE]") continue;

            const jsonChunk = JSON.parse(line.replace("data: ", "").trim());
            const content = jsonChunk?.choices?.[0]?.delta?.content;
            if (content) {
              combinedContent += content;
            }
          }
        } catch (e) {
          console.error("Error parsing JSON chunk:", e);
        }
      }

      const lines_ = combinedContent.split('\n');
      let currentTrip: TripSuggestion = {
        destination: '',
        Highlights: '',
        Country: '',
        Cost: '',
        Image: '',
        Latitude: '',
        Longitude: '',
        Tips: '',
        AdditionalActivities: '',
        Duration: '',
        BestTimeToVisit: '',
        Address: '',
        image: '',
      };

      for (let i = 0; i < lines_.length; i++) {
        let line1 = lines_[i];

        if (line1.trim().match(/^\d+\./)) {
          if (currentTrip.destination) {
            tripSuggestions.push(currentTrip);
            currentTrip = {
              destination: '',
              Highlights: '',
              Country: '',
              Cost: '',
              Image: '',
              Latitude: '',
              Longitude: '',
              Tips: '',
              AdditionalActivities: '',
              Duration: '',
              BestTimeToVisit: '',
              Address: '',
              image: '',
            };
          }
          if (line1.split('**')[1]) {
            currentTrip.destination = line1.split('**')[1]?.trim() || "Unknown Destination";
          }
        }

        if (line1.trim().startsWith("- Highlights:")) {
          currentTrip.Highlights = line1.split(":")[1]?.trim() || "Highlights not available";
        }

        if (line1.trim().startsWith("- Country:")) {
          currentTrip.Country = line1.split(":")[1]?.trim() || "Country not available";
        }

        if (line1.trim().startsWith("- Cost:")) {
          currentTrip.Cost = line1.split(":")[1]?.trim() || "Cost not available";
        }

        if (line1.trim().startsWith("- Image:")) {
          currentTrip.Image = line1.split(":")[1]?.trim() || "Image not available";
        }

        if (line1.trim().startsWith("- Latitude:")) {
          currentTrip.Latitude = line1.split(":")[1]?.trim() || "Latitude not available";
        }

        if (line1.trim().startsWith("- Longitude:")) {
          currentTrip.Longitude = line1.split(":")[1]?.trim() || "Longitude not available";
        }

        if (line1.trim().startsWith("- Tips:")) {
          currentTrip.Tips = line1.split(":")[1]?.trim() || "Tips not available";
        }

        if (line1.trim().startsWith("- Additional Activities:")) {
          currentTrip.AdditionalActivities = line1.split(":")[1]?.trim() || "Additional activities not available";
        }

        if (line1.trim().startsWith("- Duration:")) {
          currentTrip.Duration = line1.split(":")[1]?.trim() || "Duration not available";
        }

        if (line1.trim().startsWith("- Best Time to Visit:")) {
          currentTrip.BestTimeToVisit = line1.split(":")[1]?.trim() || "Best time to visit not available";
        }

        if (line1.trim().startsWith("- Address:")) {
          currentTrip.Address = line1.split(":")[1]?.trim() || "Address not available";
        }
      }

      if (currentTrip.destination) {
        tripSuggestions.push(currentTrip);
      }

      tripSuggestionsRef.current = tripSuggestions;
      setTripSuggestions(tripSuggestions);
      const destinations = [...fetchedDestinations, ...tripSuggestions.map(trip => trip.destination)];
      setFetchedDestinations(destinations);
      return tripSuggestions;
    } catch (error) {
      console.error("Error fetching trip suggestions:", error);
      return [];
    } finally {
      setIsLoading(false);
      insertTripSuggestions(tripSuggestions);
    }
  };

  const fetchSuggestions = async (apiUrl: any, apiKey: any, model: any, excludeDestinations: string): Promise<TripSuggestion[]> => {
    try {
      const response = await fetch(apiUrl + "?key=" + apiKey, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          contents: [
            {
              parts: [
                {
                  text: `Suggestion Best most visited 10 places to visit in ${destinationInput || searchParams.get(
                    "destination"
                  )}. Please please Do not include these places ${excludeDestinations} also do not include records which are not near by to ${destinationInput || searchParams.get(
                    "destination"
                  )}. Also places should be approximately ${radius} km radius.

Always Give data in this format (Please always give data in this format only strictly) >>

You can explore some of the most beautiful and exotic destinations. Here are 10 places you can
consider:

1. **Amer Fort, Jaipur, India**

- Highlights: Amer Fort or Amber Fort is a fort located in Amer, Rajasthan, India. Amer is a town with an area of 4 square kilometres (1.5 sq mi) located 11 kilometres (6.8 mi) from Jaipur, the capital of Rajasthan. Located high on a hill, it is the principal tourist attraction in Jaipur. Amer Fort is known for its artistic style elements. With its large ramparts and series of gates and cobbled paths, the fort overlooks Maota Lake, which is the main source of water for the Amer Palace.`,
                },
              ],
            },
          ],
        }),
      });

      const data = await response.json();
      const responseText = data.candidates[0].content.parts[0].text;

      let combinedContent = responseText;
      const tripSuggestions: TripSuggestion[] = [];
      const lines = combinedContent.split("\n");

      let currentTrip: TripSuggestion = {
        destination: "",
        Highlights: "",
        Country: "",
        Cost: "",
        Image: "",
        Latitude: "",
        Longitude: "",
        Tips: "",
        AdditionalActivities: "",
        Duration: "",
        BestTimeToVisit: "",
        Address: "",
        image: ""
      };

      for (let i = 0; i < lines.length; i++) {
        let line1 = lines[i];

        if (line1.trim().match(/^\d+\./)) {
          if (currentTrip.destination) {
            tripSuggestions.push(currentTrip);
            currentTrip = {
              destination: "",
              Highlights: "",
              Country: "",
              Cost: "",
              Image: "",
              Latitude: "",
              Longitude: "",
              Tips: "",
              AdditionalActivities: "",
              Duration: "",
              BestTimeToVisit: "",
              Address: "",
              image: ""
            };
          }
          if (line1.split("**")[1]) {
            currentTrip.destination = line1.split("**")[1]?.trim() || "Unknown Destination";
          }
        }

        if (line1.includes("Highlights:")) {
          let highlights = line1.split("Highlights:")[1]?.trim() || "Highlights not available";
          while (i + 1 < lines.length && !lines[i + 1].trim().match(/^\d+\.\s*\*\*.*\*\*/) && !lines[i + 1].trim().startsWith("-")) {
            i++;
            highlights += " " + lines[i].trim();
          }
          currentTrip.Highlights = highlights;
        }

        if (line1.trim().startsWith("- Country:")) currentTrip.Country = line1.split(":")[1]?.trim() || "Country not available";
        if (line1.trim().startsWith("- Cost:")) currentTrip.Cost = line1.split(":")[1]?.trim() || "Cost not available";
        if (line1.trim().startsWith("- Latitude:")) currentTrip.Latitude = line1.split(":")[1]?.trim() || "Latitude not available";
        if (line1.trim().startsWith("- Longitude:")) currentTrip.Longitude = line1.split(":")[1]?.trim() || "Longitude not available";
        if (line1.trim().startsWith("- Tips:")) currentTrip.Tips = line1.split(":")[1]?.trim() || "Tips not available";
        if (line1.trim().startsWith("- Additional Activities:")) currentTrip.AdditionalActivities = line1.split(":")[1]?.trim() || "Additional activities not available";
        if (line1.trim().startsWith("- Duration:")) currentTrip.Duration = line1.split(":")[1]?.trim() || "Duration not available";
        if (line1.trim().startsWith("- Best Time to Visit:")) currentTrip.BestTimeToVisit = line1.split(":")[1]?.trim() || "Best time to visit not available";
        if (line1.trim().startsWith("- Address:")) currentTrip.Address = line1.split(":")[1]?.trim() || "Address not available";
      }

      if (currentTrip.destination) {
        tripSuggestions.push(currentTrip);
      }

      tripSuggestionsRef.current = tripSuggestions;
      setTripSuggestions(tripSuggestions);
      const destinations = [...fetchedDestinations, ...tripSuggestions.map(trip => trip.destination)];
      setFetchedDestinations(destinations);

      return tripSuggestions;
    } catch (error) {
      console.error("Error fetching trip suggestions:", error);
      return [];
    } finally {
      setIsLoading(false);
    }
  };

  async function fetchImageMediaWIKI(destination: string): Promise<any> {
    const url = `${WIKI_MEDIA_API_URL}${encodeURIComponent(destination)}&gsrnamespace=6&prop=imageinfo&iiprop=url&origin=*`;

    try {
      const response = await fetch(url, {
        headers: { "User-Agent": navigator.userAgent },
      });

      const data = await response.json();
      const pages = data.query?.pages;
      if (pages) {
        const firstPage = Object.values(pages)[0];
        const imageUrl = (firstPage as any).imageinfo?.[0]?.url;
        return imageUrl?.startsWith("http") ? imageUrl : `https:${imageUrl}`;
      }
    } catch (error) {
      console.error("Error fetching image:", error);
    }
    return null;
  }

  async function getFlickrImages(place: string, gallery?: any): Promise<string[]> {
    let apiKey = '';
    if (gallery) {
      apiKey = '74a9b070d21072ccac3a7b5f44f09efa';
    } else {
      apiKey = 'ca8aa2ae5c208b3e28e2dd5ada0f1407';
    }
    const url = `https://api.flickr.com/services/rest/?method=flickr.photos.search&api_key=${apiKey}&text=${encodeURIComponent(place)}&format=json&nojsoncallback=1&sort=relevance&per_page=20`;

    try {
      const response = await fetch(url);
      if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      const data = await response.json();
      if (!data.photos || !data.photos.photo) return [];

      const photos = data.photos.photo;
      return photos.map((photo: any) =>
        `https://farm${photo.farm}.staticflickr.com/${photo.server}/${photo.id}_${photo.secret}_b.jpg`
      );
    } catch (error) {
      console.error('Error fetching Flickr images:', error);
      return [];
    }
  }

  async function fetchImage(destination: string): Promise<any> {
    let imageUrl = await getFlickrImages(destination);
    return imageUrl[0] || "https://images.unsplash.com/photo-1503220317375-aaad61436b1b";
  }

  async function fetchImagesForNewSuggestions(newTripSuggestions: TripSuggestion[]) {
    if (newTripSuggestions.length > 0) {
      const updatedTrips = await Promise.all(
        newTripSuggestions.map(async (tripItem) => {
          const imageUrl = await fetchImage(tripItem.destination);
          return { ...tripItem, image: imageUrl || 'https://images.unsplash.com/photo-1503220317375-aaad61436b1b' };
        })
      );
      setTripSuggestions(updatedTrips);
      setImagesFetched(true);
    }
  }

  const handleViewCombinedItinerary = () => {
    if (selectedTrips.length > 0) {
      updateDestinationWeightage(selectedTrips);
      const existingParams = new URLSearchParams(window.location.search);
      const newParams = new URLSearchParams({ trips: selectedTrips.join(',') });

      for (const [key, value] of existingParams.entries()) newParams.set(key, value);
      router.push(`/combined-itinerary?${newParams.toString()}`);
    }
  };

  useEffect(() => {
    async function fetchImagesOnMount() {
      if (tripSuggestions.length > 0 && !imagesFetched) {
        await fetchImagesForNewSuggestions(tripSuggestions);
      }
    }

    fetchImagesOnMount();
  }, [tripSuggestions, imagesFetched]);

  if (isLoading && tripSuggestionsRef.current.length === 0) {
    return (
      <div className="fixed inset-0 flex items-center justify-center bg-[rgb(255,88,93,0.05)]">
        <div className="text-center space-y-6">
          <div className="relative flex items-center justify-center">
            <div className="absolute inset-0 bg-[rgb(255,88,93,0.2)] rounded-full animate-ping" />
            <Plane className="h-16 w-16 text-[rgb(255,88,93)] animate-bounce" />
          </div>
          <p className="text-2xl font-medium text-[rgb(255,88,93)] animate-pulse">Discovering Perfect Trips</p>
          <p className="text-gray-600">Tailoring suggestions to your preferences...</p>
        </div>
      </div>
    );
  }

  return (
    <>
      <ToastContainer />
      <Navbar />
      <div className="min-h-screen bg-gradient-to-br from-[rgb(255,88,93,0.05)] to-[rgb(255,88,93,0.02)] bg-background pt-20 relative">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 ">
          <div className="flex justify-between items-center">
            <div>
              <Button
                variant="outline"
                onClick={toggleSearchOverlay}
                className="flex items-center gap-2"
              >
                <Search className="h-5 w-5 text-[rgb(255,88,93)]" />
                Edit Search
              </Button>
            </div>
            <div className="flex justify-between items-center">
              <span
                onClick={handleNext20}
                className="flex bg-[rgb(255,88,93)] items-center gap-2 cursor-pointer text-white px-4 py-2 rounded-full border shadow-md transition-all duration-300"
              >
                Next 10 Places
                <ArrowRight className="h-5 w-5" />
              </span>
            </div>
          </div>

          <div className="mb-2 p-3 text-black rounded-lg mt-4 shadow-md animate-fade-in text-xs">
            <p>Select places to see the combined itinerary.</p>
          </div>

          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 mt-4">
            {isLoading
              ? Array(6)
                  .fill(0)
                  .map((_, index) => (
                    <Card key={index} className="overflow-hidden">
                      <Skeleton className="h-48 w-full bg-gray-300" />
                      <div className="p-4 space-y-2">
                        <Skeleton className="h-6 w-3/4 bg-gray-300" />
                        <Skeleton className="h-4 w-1/2 bg-gray-300" />
                        <Skeleton className="h-4 w-5/6 bg-gray-300" />
                        <Skeleton className="h-10 w-full bg-gray-300" />
                      </div>
                    </Card>
                  ))
              : tripSuggestions.map((trip) => {
                  const isSelected = selectedTrips.includes(trip.destination);
                  const isFavorited = favoritedTrips.includes(trip.destination);
                  const isHovered = hoveredCard === trip.destination;

                  return (
                    <Card
                      key={trip.destination}
                      className={`overflow-hidden relative transition-all duration-300 transform ${isSelected ? 'ring-2 ring-primary ring-offset-2 scale-[1.02]' : 'hover:scale-[1.01]'}`}
                      onMouseEnter={() => setHoveredCard(trip.destination)}
                      onMouseLeave={() => setHoveredCard(null)}
                    >
                      <div
                        className="absolute top-4 left-4 z-10 cursor-pointer"
                        onClick={(e) => handleFavoriteTrip(trip.destination, trip.Highlights, trip.image, e)}
                      >
                        <div className="bg-background text-foreground w-8 h-8 rounded-full flex items-center justify-center shadow-lg">
                          <Heart
                            className={`h-5 w-5 ${isFavorited ? 'text-red-500 fill-red-500' : 'text-gray-500'}`}
                          />
                        </div>
                      </div>

                      <div
                        className="absolute top-4 right-4 z-10 cursor-pointer"
                        onClick={(e) => handleTripSelection(trip.destination, e)}
                      >
                        <div className="bg-background text-foreground w-8 h-8 rounded-full flex items-center justify-center shadow-lg">
                          {isSelected ? <Check className="h-5 w-5 text-green-600" /> : <Plus className="h-5 w-5" />}
                        </div>
                      </div>

                      {isSelected && (
                        <div className="absolute inset-0 bg-primary/10 pointer-events-none transition-opacity duration-300" />
                      )}

                      <div
                        onClick={(e) => handleViewDetails(trip.destination, e)}
                        className="h-48 bg-cover bg-center relative transition-transform duration-300"
                        style={{ backgroundImage: `url(${trip.image})` }}
                      />

                      <div className="p-4">
                        <div className="flex items-center justify-between gap-2 mb-2">
                          <div className="flex items-center gap-2">
                            <MapPin className="h-4 w-4 text-primary" />
                            <h3 className="font-semibold">
                              <a
                                href={`https://www.google.com/maps/search/?api=1&query=${encodeURIComponent(trip.destination)}`}
                                target="_blank"
                                rel="noopener noreferrer"
                                className="font-semibold hover:underline"
                              >
                                {trip.destination}
                              </a>
                            </h3>
                          </div>
                          <button
  onClick={(e) => openImageGallery(trip.destination, e)}
  className="relative p-1 hover:bg-rose-50 rounded-full group transition-colors"
  aria-label="View more images"
>
  <div className="flex flex-col items-center gap-1">
    <ImageIcon className="h-6 w-6 text-rose-500 group-hover:scale-110 transition-transform duration-200" />
    <div className="flex gap-[2px]">
      <span className="h-1 w-1 bg-rose-500 rounded-full" />
      <span className="h-1 w-1 bg-rose-500 rounded-full" />
      <span className="h-1 w-1 bg-rose-500 rounded-full" />
    </div>
  </div>
</button>
                        </div>

                        <div className="mb-4" onClick={(e) => handleViewDetails(trip.destination, e)}>
                          <h4 className="font-medium mb-2">Highlights:</h4>
                          <p className="text-muted-foreground">{trip.Highlights}</p>
                        </div>

                        <Button
                          className="w-full bg-[rgb(255,88,93)] hover:bg-[rgb(255,88,93)]"
                          onClick={(e) => handleViewDetails(trip.destination, e)}
                        >
                          View Details
                        </Button>
                      </div>
                    </Card>
                  );
                })}
          </div>
        </div>

        {selectedTrips.length > 0 && (
          <div className="fixed left-0 right-0 bottom-4 bg-[rgb(255,88,93)] text-white p-4 shadow-lg z-40 rounded-3xl mx-4">
            <div className="max-w-7xl mx-auto flex justify-between items-center">
              <p className="text-sm font-semibold">
                Yay! {selectedTrips.length} place{selectedTrips.length > 1 ? 's' : ''} added
              </p>
              <Button
                onClick={handleViewCombinedItinerary}
                className="bg-white text-black hover:bg-gray-200 hover:text-black transition-colors"
              >
                View Itinerary <ArrowRight className="h-5 w-5" />
              </Button>
            </div>
          </div>
        )}

        {isGalleryOpen && (
          <div
            className="fixed inset-0 bg-black/80 z-50 flex items-end justify-center transition-opacity duration-300"
            onClick={closeGallery}
          >
            <div
              className={`bg-white rounded-t-lg w-full max-w-3xl transform transition-transform duration-500 ease-in-out ${
                isGalleryOpen ? 'translate-y-0 opacity-100' : 'translate-y-full opacity-0'
              }`}
              onClick={e => e.stopPropagation()}
            >
              <div className="sticky top-0 bg-white z-10 p-6 border-b rounded-t-lg flex justify-between items-center">
                <h2 className="text-xl font-semibold text-[rgb(255,88,93)]">{currentDestination}</h2>
                <button
                  onClick={closeGallery}
                  className="p-1 hover:bg-gray-100 rounded-full"
                >
                  <svg
                    className="w-6 h-6 text-gray-600"
                    fill="none"
                    stroke="currentColor"
                    viewBox="0 0 24 24"
                  >
                    <path
                      strokeLinecap="round"
                      strokeLinejoin="round"
                      strokeWidth={2}
                      d="M6 18L18 6M6 6l12 12"
                    />
                  </svg>
                </button>
              </div>

              <div className="p-6 pt-0 max-h-[80vh] overflow-y-auto">
                <div className="grid grid-cols-2 gap-4">
                  {galleryImages.length > 0 ? (
                    galleryImages.map((imgUrl, index) => (
                      <img
                        key={index}
                        src={imgUrl}
                        alt={`${currentDestination} ${index + 1}`}
                        className="w-full h-48 object-cover rounded-lg cursor-pointer hover:opacity-80 transition-opacity"
                        onClick={() => setSelectedImageIndex(index)}
                        onError={(e) => {
                          (e.target as HTMLImageElement).src = 'https://images.unsplash.com/photo-1503220317375-aaad61436b1b';
                        }}
                      />
                    ))
                  ) : (
                    <p>No images available</p>
                  )}
                </div>
              </div>
            </div>

            {/* Image Viewer Overlay with Swipe Gestures */}
            {selectedImageIndex !== null && (
              <div
                className="fixed inset-0 bg-black/90 z-[60] flex items-center justify-center"
                onClick={() => setSelectedImageIndex(null)}
              >
                <div
                  className="relative w-full max-w-4xl"
                  onClick={e => e.stopPropagation()}
                  onTouchStart={handleTouchStart}
                  onTouchMove={handleTouchMove}
                  onTouchEnd={handleTouchEnd}
                >
                  {/* Close Button */}
                  <button
                    onClick={() => setSelectedImageIndex(null)}
                    className="absolute top-4 right-4 z-10 p-2 bg-white/20 rounded-full hover:bg-white/30"
                  >
                    <svg
                      className="w-6 h-6 text-white"
                      fill="none"
                      stroke="currentColor"
                      viewBox="0 0 24 24"
                    >
                      <path
                        strokeLinecap="round"
                        strokeLinejoin="round"
                        strokeWidth={2}
                        d="M6 18L18 6M6 6l12 12"
                      />
                    </svg>
                  </button>

                  {/* Previous Button */}
                  {selectedImageIndex > 0 && (
                    <button
                      onClick={() => setSelectedImageIndex(prev => (prev !== null ? prev - 1 : prev))}
                      className="absolute left-4 top-1/2 transform -translate-y-1/2 p-2 bg-white/20 rounded-full hover:bg-white/30"
                    >
                      <svg
                        className="w-6 h-6 text-white"
                        fill="none"
                        stroke="currentColor"
                        viewBox="0 0 24 24"
                      >
                        <path
                          strokeLinecap="round"
                          strokeLinejoin="round"
                          strokeWidth={2}
                          d="M15 19l-7-7 7-7"
                        />
                      </svg>
                    </button>
                  )}

                  {/* Next Button */}
                  {selectedImageIndex < galleryImages.length - 1 && (
                    <button
                      onClick={() => setSelectedImageIndex(prev => (prev !== null ? prev + 1 : prev))}
                      className="absolute right-4 top-1/2 transform -translate-y-1/2 p-2 bg-white/20 rounded-full hover:bg-white/30"
                    >
                      <svg
                        className="w-6 h-6 text-white"
                        fill="none"
                        stroke="currentColor"
                        viewBox="0 0 24 24"
                      >
                        <path
                          strokeLinecap="round"
                          strokeLinejoin="round"
                          strokeWidth={2}
                          d="M9 5l7 7-7 7"
                        />
                      </svg>
                    </button>
                  )}

                  {/* Main Image */}
                  <img
                    src={galleryImages[selectedImageIndex]}
                    alt={`${currentDestination} ${selectedImageIndex + 1}`}
                    className="w-full max-h-[90vh] object-contain"
                    onError={(e) => {
                      (e.target as HTMLImageElement).src = 'https://images.unsplash.com/photo-1503220317375-aaad61436b1b';
                    }}
                  />

                  {/* Image Counter */}
                  <div className="absolute bottom-4 left-1/2 transform -translate-x-1/2 bg-black/50 text-white px-3 py-1 rounded-full">
                    {selectedImageIndex + 1} / {galleryImages.length}
                  </div>
                </div>
              </div>
            )}
          </div>
        )}

        {isSearchOverlayOpen && (
          <div
            className="fixed inset-0 flex items-start justify-center mt-16"
            onClick={toggleSearchOverlay}
          >
            <div
              className="bg-white w-full max-w-md p-4 rounded-lg shadow-xl animate-fade-in relative"
              onClick={(e) => e.stopPropagation()}
            >
              <button
                onClick={toggleSearchOverlay}
                className="absolute top-2 right-4 p-1 hover:bg-gray-100 rounded-full"
              >
                <svg
                  className="w-6 h-6 text-gray-600"
                  fill="none"
                  stroke="currentColor"
                  viewBox="0 0 24 24"
                >
                  <path
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    strokeWidth={2}
                    d="M6 18L18 6M6 6l12 12"
                  />
                </svg>
              </button>
              <form onSubmit={handleSearchSubmit} className="space-y-3">
                <div>
                  <label className="block text-sm font-medium mb-1">From</label>
                  <Input
                    value={fromInput}
                    onChange={(e) => setFromInput(e.target.value)}
                    placeholder="Enter starting city"
                    className="w-full"
                  />
                </div>
                <div>
                  <label className="block text-sm font-medium mb-1">Destination</label>
                  <Input
                    value={destinationInput}
                    onChange={(e) => setDestinationInput(e.target.value)}
                    placeholder="Enter destination"
                    className="w-full"
                  />
                </div>
                <div className="flex justify-end">
                  <Button type="submit" className="bg-[rgb(255,88,93)] hover:bg-primary/90">
                    Update Search
                    <ArrowRight className="ml-2 h-4 w-4" />
                  </Button>
                </div>
              </form>
            </div>
          </div>
        )}
      </div>
      <Footer />
    </>
  );
};

export default Results;
